#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      Gaurav Singhal

# Created:     24/08/2012
# Copyright:   (c) Gaurav Singhal 2012
# Licence:     This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 Unported License.
#              To view a copy of this license, visit http://creativecommons.org/licenses/by-nc/3.0/.
#-------------------------------------------------------------------------------

import sys
import random, math


'''
targetBed: Target coordinates of capture platform. We mostly use Agilent SureSelect V3 or V4.
pileupFile: pileup file generated by samtools. This pileup file should preferably have information only for bases within the target/capture coordinates.

printCoveragetoFile(pileupFile1, targetBed1, patient_name): added on April 1, 2013

'''
def surveyCoverage(pileupFile, targetBed):

    fh1 = open(targetBed, 'rU')
    data = fh1.readlines()
    fh1.close()
    locations = []

    # reading the targetBed file
    for each in data:
        flds = each.split('\t')
        locations.append([flds[0].strip(), int(flds[1].strip()), int(flds[2].strip()), 0])# here, this zero will be replaced by coverage, which is calculated later

    # reading the pileup file. we are creating a dict with key=chr#coord and val = depth of coverage
    loc_depth = {}
    fh2 = open(pileupFile, 'rU')
    for line in fh2:
        flds = line.split('\t')
        key = flds[0].strip() + '#' + flds[1].strip()
        loc_depth[key] = int(flds[3].strip())
    fh2.close()


    for z in range(len(locations)):

        numLoci = ((locations[z][2] - locations[z][1])/40)+1  # this is the number of locations where we will sample the depth of coverage
##        print numLoci
        coverage = 0
        st = locations[z][1]+1
        end = locations[z][2]
        for i in range(numLoci):
            max_iters = 50  # we are going to sample the target location 50 times. we need numLoci samples of coverage
            while max_iters>0:
                max_iters-=1
                baseLoc = random.randint(st, end)

                key = locations[z][0] + '#' + str(baseLoc)
                if key in loc_depth:
                    break  # else repeat
            if key not in loc_depth:
                coverage+=0


            else:
                coverage+= loc_depth[key]
        meanCoverage = coverage/float(numLoci)
        locations[z][3] = meanCoverage

    return locations




def correlation(pileupFile1, targetBed1, pileupFile2, targetBed2, patient_name):

    one = surveyCoverage(pileupFile1, targetBed1)
    two = surveyCoverage(pileupFile2, targetBed2)
    outfileName = patient_name + 'meanCoverage.csv'
    fhout = open(outfileName, 'w')
    if len(one) != len(two):
        print 'Target Bed files are of unequal length. Please use the same target bed files. Exiting now !'
        sys.exit()
    else:
        for i in range(len(one)):
            outline = str(one[i][3]) + ','+ str(two[i][3]) + '\n'
            fhout.write(outline)
    fhout.close()


def printCoveragetoFile(pileupFile1, targetBed1, patient_name):
    one = surveyCoverage(pileupFile1, targetBed1)

    outfileName = patient_name + 'meanCoverage.csv'
    fhout = open(outfileName, 'w')
##    if len(one) != len(two):
##        print 'Target Bed files are of unequal length. Please use the same target bed files. Exiting now !'
##        sys.exit()
##    else:
    for i in range(len(one)):
        outline = str(one[i][0]) + ':' + str(one[i][1]) + '-' +str(one[i][2]) + ',' + str(one[i][3]) +  '\n'
        fhout.write(outline)
    fhout.close()


def printAllCoveragetoFile():
    filelist = open('SJ_renal_dysplasia_bam_files.csv', 'rU').readlines()
    targetBedFile  = 'S0347602_BED_20110607.bed'
    AllCoverageData = []
    allPatients = ','
    for each in filelist:
        PT_name = each.split(',')[0].strip()[:-4]
        allPatients+=PT_name + ','

        pileupFile  = PT_name + '_mpileup.txt'
        AllCoverageData.append(surveyCoverage(pileupFile, targetBedFile))

    allPatients+='\n'
    outfileName = 'All_patients_meanCoverage.csv'
    fhout = open(outfileName, 'w')
    fhout.write(allPatients)

##    if len(one) != len(two):
##        print 'Target Bed files are of unequal length. Please use the same target bed files. Exiting now !'
##        sys.exit()
##    else:


    for i in range(len(AllCoverageData[0])):
        outline = str(AllCoverageData[0][i][0]) + ':' + str(AllCoverageData[0][i][1]) + '-' +str(AllCoverageData[0][i][2]) +','
##        outline = str(one[i][0]) + ':' + str(one[i][1]) + '-' +str(one[i][2]) + ',' + str(one[i][3]) +  '\n'
        for j in range(len(AllCoverageData)):

            outline += str(AllCoverageData[j][i][3]) + ','
##        outline = str(one[i][0]) + ':' + str(one[i][1]) + '-' +str(one[i][2]) + ',' + str(one[i][3]) +  '\n'
        outline+='\n'
        fhout.write(outline)
    fhout.close()


def coverageAnalysis(filein):
    fh = open(filein, 'rU')
    data = fh.readlines()
    fh.close()

    covs = []

    for line in data:
        flds = line.split(',')
        covs.append([float(flds[0].strip()), float(flds[1].strip())])

    sortedCovs = sorted(covs, reverse=True)

    print covs[:20]

    print '#################'

    print sortedCovs[:20]

    print len(sortedCovs)

    top95 = sortedCovs[:176354]

##    print top95[-31600:-31554]
    above20 = []
    for each in sortedCovs:
        if each[0] > 20.00:
            if each[1]>20.00:
                above20.append(each)

    print "# of targets with > 20x sequencing = ", len(above20), "which is ", str((float(len(above20))/len(sortedCovs))*100.00) ,'% of total targets'

    print above20[-10:]


def main():
##    pileupFile1 = sys.argv[1]
##    targetBed1 = sys.argv[2]
####    pileupFile2 = sys.argv[3]
####    targetBed2 = sys.argv[4]
##    patient_name = sys.argv[3]
####    correlation(pileupFile1, targetBed1, pileupFile2, targetBed2, patient_name)
##    printCoveragetoFile(pileupFile1, targetBed1, patient_name)
    printAllCoveragetoFile()
##    coverageAnalysis('PT_3_meanCoverage.csv')
if __name__ == '__main__':
    main()
